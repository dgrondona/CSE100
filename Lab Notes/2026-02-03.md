# 2026-02-03

**1.** *(basic)* Run Insertion Sort on input array A = 〈 5 , 8 , 4 , 2 , 3 , 1 〉, show how the array looks before each iteration of the for loop in line 1; see page 18 for the pseudo-code.

---

**2.** *(basic)* Show the operation of Merge sort on the arrayA=〈 7 , 4 , 2 , 8 , 3 , 1 , 5 , 6 , 9 〉as shown in Fig. 2.4.

---

**3.** *(Intermediate)* The following is a pseudo-code of Selection-Sort. Describe Selection-Sort in plain English.

Selection-Sort(A)
1. n = A.length
2. for $j = 1$ to $n$
3. smallest = j
4. for $i = j+1$ to $n$
5. if `A[i] < A[smallest]`
6. smallest = i
7. exchange A[j] with A[smallest]

State the loop invariant and prove that the algorithm is correct. What is the running time?

---

**4.** *(basic)* Suppose there are $2n$ inputs to a certain problem. The running time of algorithm A is exactly $2n$ for exactly one of the inputs, and 1 for any other input. Then, the running time is $O(1)$ since

```math
2^n*\frac{1}{2^n}+1*(1-\frac{1}{2^n}) \le 2
```

Is this statement correct?

- O(n) would mean worst case, it would have to go through all of the elements.
- In this case, the n^2 is the worst case senerio
- It WOULD be $O(1)$ for 1 element, but we wouldn't say that the running time would be that.

---

**5.** *(basic)* Suppose the input sequence is already sorted. For this specific input, what is the running time of Insertion-sort and Merge-sort? Assume that they are implemented as in the textbook.

---

**6.** *(basic)* Answer the same question as above when the input is〈n, n− 1 ,... , 1 〉.

---

**7.** *(basic)* Briefly explain the computational model, RAM (Random Access Model).

---

**8.** *(intermediate)* Consider the pseudocode of M erge(A, p, q, r) in the textbook. Given that A[p...q] and A[q+ 1...r] are both sorted, the function call merges the two sorted subarrays into a sorted subarrayA[p...r]. Prove the correctness of Merge. For simplicity, you can assume that L[1...$n_1$] = A[p...q] and R[1...$n_2$] = A[q+1...r], and L[$n_1$ + 1] =R[$n_2$ + 1] = ∞.(So you only need to consider from lines 10). You can assume that all elements stored in the array have distinct values.

- We have our 9 elements, and we can split into [7,4,2,6,1] and [8,3,5,9]

---

**9.** *(intermediate/advanced)* Consider the searching problem: The input is an arrayA[1···n] of numbers and a value v. You’re asked to find an index such that A[i] =v. If there’s no such index, return NIL. The following is a pseudocode of linear search, which scans through the sequence, looking forv. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties. What is the asymptotic worst case running time?

1. For i = 1 to n
2. If A[i] == v then return i
3. return NIL.

---

**10.** *(advanced)* You’re given an arrayA[1···n] ofnnumbers, and would like to know if the
array includes two equal numbers. Describe an algorithm that does this job for you. The
running time must beO(nlogn).

---

**11.** *(advanced)* We’re given three sorted arraysA[1···x],B[1···y],C[1···z]. Describe an
algorithm that merges the given three sorted (in increasing order) arrays into one (sorted
array). What is the running time?

---

**12.** *(basic)* Merge sort is always faster than insertion sort. True or false?. Justify your answer.

> When the list is sorted already, or the list is very small, InsertionSort can be faster than MergeSort.

---

**13.** *(intermediate)* Observe that if the sequenceAis sorted, we can check the midpoint of the
sequence againstv(the element we’re looking for) and eliminate half of the sequence from
further consideration. The binary search algorithm repeats this procedure, halving the size
of the remaining portion of the sequence each time. The following is a recursion-based
pseudo-code is supposed the following: returns an indexisuch thatp≤i≤randA[i] =v
if such an index exists, and returns -1 otherwise. Prove the correctness via induction.

```
BSearch(A, p, r, v)
If r < p, return -
q = the floor of (p + r)/
if A[q] == v return q
else if v < A[q] return BSearch(A, p, q-1, v)
else return BSearch(A, q+1, r, v)
```

---

**14.** *(intermediate)* Can you use binary search to improve the running time of insertion sort to O(nlogn)?

---